/*	$NetBSD: tp_driver.c,v 1.19 2005/12/11 12:25:12 christos Exp $	*/


#include <nettpi/tpi_pcb.h>
#include <nettpi/tpi_tpdu.h>

#include <netiso/tp_param.h>
#include <netiso/tp_stat.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_trace.h>
#include <netiso/iso_errno.h>
#include <netiso/tp_seq.h>

#include "tp_events.h"

static struct act_ent {
	int a_newstate;
	int a_action;
};

static struct act_ent statetable[] = {
		.a_newstate = 0,
		.a_action = 0
};

static struct act_ent erroraction = {
		.a_newstate = 0,
		.a_action = -1
};


/*
 * From tp_states.init
 */
#define ST_ERROR 		0x0
#define TP_CLOSED 		0x1
#define TP_CRSENT 		0x2
#define TP_AKWAIT 		0x3
#define TP_OPEN 		0x4
#define TP_CLOSING 		0x5
#define TP_REFWAIT 		0x6
#define TP_LISTENING 	0x7
#define TP_CONFIRMING 	0x8

struct act_ent tpdu_states[] = {
    { 0x3, 0x0 },
    { 0x6, 0x1 },
    { 0x6, 0x2 },
    { 0x6, 0x0 },
    { 0x2, 0x3 },
    { 0x2, 0x0 },
    { 0x1, 0x0 },
    { 0x5, 0x0 },
    { 0x4, 0x0 },
    { 0x7, 0x0 },
    { 0x7, 0x0 },
    { 0x1, 0x4 },
    { 0x8, 0x5 },
    { 0x8, 0x6 },
    { 0x4, 0x7 },
    { 0x3, 0x8 },
    { 0x1, 0x9 },
    { 0x2, 0xa },
    { 0x6, 0xb },
    { 0x1, 0xc },
    { 0x6, 0xd },
    { 0x6, 0xe },
    { 0x6, 0xf },
    { 0x6, 0x10 },
    { 0x1, 0x11 },
    { 0x6, 0x12 },
    { 0x5, 0x13 },
    { 0x4, 0x14 },
    { 0x4, 0x15 },
    { 0x2, 0x16 },
    { 0x6, 0x17 },
    { 0x3, 0x18 },
    { 0x4, 0x19 },
    { 0x4, 0x1a },
    { 0x4, 0x1b },
    { 0x3, 0x1c },
    { 0x4, 0x1c },
    { 0x4, 0x1d },
    { 0x4, 0x1e },
    { 0x4, 0x1f },
    { 0x4, 0x20 },
    { 0x3, 0x20 },
    { 0x6, 0x21 },
    { 0x5, 0x22 },
    { 0x6, 0x23 },
    { 0x5, 0x24 },
    { 0x3, 0x25 },
    { 0x5, 0x26 },
    { 0x5, 0x27 },
    { 0x4, 0x28 },
    { 0x4, 0x29 },
    { 0x5, 0x2a },
    { 0x6, 0x2b },
    { 0x1, 0x2c },
    { 0x4, 0x2d },
    { 0x4, 0x2e },
    { 0x4, 0x2f },
    { 0x4, 0x30 },
    { 0x4, 0x31 },
    { 0x4, 0x32 },
    { 0x4, 0x33 },
    { 0x4, 0x34 },
    { 0x4, 0x35 },
    { 0x4, 0x36 },
    { 0x6, 0x37 },
    { 0x6, 0x38 },
    { 0x7, 0x0 },
    { 0x5, 0x0 },
    { 0x3, 0x0 },
    { 0x2, 0x0 },
    { 0x4, 0x0 },
    { 0x6, 0x0 },
    { 0x1, 0x0 },
};

static int
_Xebec_action(int a, struct tpdu *e, struct tpipcb *p)
{
	switch (a) {

	/* 0x0 - 0xf */
	case 0x0:
	case 0x1:
	case 0x2:
	case 0x3:
	case 0x4:
	case 0x5:
	case 0x6:
	case 0x7:
	case 0x8:
	case 0x9:
	case 0xa:
	case 0xb:
	case 0xc:
	case 0xd:
	case 0xe:
	case 0xf:
	/* 0x10 - 0x1f */
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1a:
	case 0x1b:
	case 0x1c:
	case 0x1d:
	case 0x1e:
	case 0x1f:
	/* 0x20 - 0x2f */
	case 0x20:
	case 0x21:
	case 0x22:
	case 0x23:
	case 0x24:
	case 0x25:
	case 0x26:
	case 0x27:
	case 0x28:
	case 0x29:
	case 0x2a:
	case 0x2b:
	case 0x2c:
	case 0x2d:
	case 0x2e:
	case 0x2f:
	/* 0x30 - 0x38 */
	case 0x30:
	case 0x31:
	case 0x32:
	case 0x33:
	case 0x34:
	case 0x35:
	case 0x36:
	case 0x37:
	case 0x38:
	}
	return (0);
}

static int
_Xebec_index(struct tp_event *e, struct tpipcb *p)
{
	int command = ((e->ev_number << 4) + (p->tpp_state));

	switch (command) {
	case 0x12:
		if (p->tpp_retrans > 0) {
			return 0x1e;
		} else {
			return 0x1f;
		}
	case 0x13:
		if (p->tpp_retrans > 0) {
			return 0x1f;
		} else {
			return 0x30;
		}
	case 0x14:
		if (p->tpp_retrans > 0) {
			return 0x32;
		} else {
			return 0x31;
		}
	case 0x15:
		if (p->tpp_retrans > 0) {
			return 0x34;
		} else {
			return 0x35;
		}
	case 0x54:
		if (p->tpp_rxtshift < TP_NRETRANS) {
			return 0x33;
		} else {
			return 0x31;
		}
	case 0x64:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x1a;
		} else {
			return 0x1b;
		}
	case 0x77:
		if (p->tpp_class == TP_CLASS_0) {
			return 0xd;
		} else {
			return 0xe;
		}
	case 0x86:
		if (e->EV_GET(DR_TPDU, sref) != 0) {
			return 0x2;
		} else {
			return 0x3;
		}
	case 0xa2:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x1c;
		} else {
			return 0x1d;
		}
	case 0xb2:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x5;
		} else {
			return 0x0;
		}
	case 0xb4:
		if (tp_goodack(p, e->EV_GET(AK_TPDU, cdt),
				e->EV_GET(AK_TPDU, seq), e->EV_GET(AK_TPDU, subseq))) {
			return 0x3a;
		} else {
			return 0x3b;
		}
	case 0xc3:
		if (IN_RWINDOW(p, e->EV_GET(DT_TPDU, seq), p->tpp_rcvnxt,
				SEQ(p, p->tpp_rcvnxt + p->tpp_lcredit))) {
			return 0x21;
		} else {
			return 0x24;
		}
	case 0xc4:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x22;
		} else if (IN_RWINDOW(p, e->EV_GET(DT_TPDU, seq), p->tpp_rcvnxt,
				SEQ(p, p->tpp_rcvnxt + p->tpp_lcredit))) {
			return 0x23;
		} else {
			return 0x25;
		}
	case 0xd3:
		if (p->tpp_Xrcvnxt == e->EV_GET(XPD_TPDU, seq)) {
			return 0x27;
		} else {
			return 0x2a;
		}
	case 0xd4:
		if (p->tpp_Xrcvnxt == e->EV_GET(XPD_TPDU, seq)) {
			return 0x27;
		} else {
			return 0x29;
		}
	case 0xe4:
		if (tp_goodXack(p, e->EV_GET(XAK_TPDU, seq))) {
			return 0x3c;
		} else {
			return 0x3d;
		}
	case 0x102:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x2d;
		} else {
			return 0x2e;
		}
	case 0x104:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x2d;
		} else {
			return 0x2e;
		}
	case 0x144:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x3f;
		} else {
			return 0x40;
		}
	case 0x162:
		if (p->tpp_class == TP_CLASS_0) {
			return 0x2b;
		} else {
			return 0x2c;
		}
	case 0x172:
		if (p->tpp_class != TP_CLASS_4) {
			return 0x42;
		} else {
			return 0x46;
		}
	case 0x174:
		if (p->tpp_class != TP_CLASS_4) {
			return 0x42;
		} else {
			return 0x47;
		}
	case 0x177:
		if (p->tpp_class != TP_CLASS_4) {
			return 0x42;
		} else {
			return 0x43;
		}
	case 0x188:
		if (p->tpp_class == TP_CLASS_0) {
			return 0xf;
		} else if (tp_emit(CC_TPDU_type, p, 0, 0, MCPY(p->tpp_ucddata, M_NOWAIT)) == 0) {
			return 0x10;
		} else {
			return 0x11;
		}
	default:
		 return 0;
	}
	return (0);
}

static int inx[26][9] = {
		{ 0, 0, 0, 0, 0, 0, 0, 0, 0,},
		{ 0x0, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, -1, -1, -1, -1, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, -1, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x7, 0x15, 0x1b, -1, 0x17, 0x3, 0xa, 0x0, },
		{ 0x0, 0x19, 0x6, 0x20, 0x37, 0x8, 0x3, -1, 0x0, },
		{ 0x0, 0x14, 0x13, 0x13, 0x13, 0x16, -1, 0xa, 0x0, },
		{ 0x0, 0x7, 0x6, 0x1, 0x9, 0x18, 0x3, 0xa, 0x0, },
		{ 0x0, 0x19, -1, 0x1, 0x37, 0x8, 0x3, 0xa, 0x0, },
		{ 0x0, 0x7, -1, 0x26, -1, 0x8, 0x3, 0xa, 0x0, },
		{ 0x0, 0x7, 0x6, -1, -1, 0x8, 0x3, 0xa, 0x0, },
		{ 0x0, 0x7, 0x6, -1, -1, 0x8, 0x3, 0xa, 0x0, },
		{ 0x0, 0x7, 0x6, 0x1, -1, 0x8, 0x3, 0xa, 0x0, },
		{ 0x0, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, -1, 0x2e, -1, 0x0, 0x4, 0x0, 0x2e, },
		{ 0x0, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x39, 0x0, 0x0, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, -1, 0x0, 0x41, 0x0, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x28, 0x0, 0x41, 0x0,	0x0, },
		{ 0x0, 0xc, -1, 0x2c, 0x0, 0x2c, 0x4, 0xc, 0x2c, },
		{ 0x0, 0x49, -1, 0x45, -1, 0x44, 0x48, -1, 0x0, },
		{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, -1, },
};

int
tp_driver(struct tpipcb *p, struct tp_event *e)
{
	register int index, error = 0;
	struct act_ent *a;

	index = inx[1 + e->ev_number][p->tpp_state];
	if (index < 0) {
		index = _Xebec_index(e, p);
	}
	if (index == 0) {
		a = &erroraction;
	} else {
		a = &statetable[index];
	}
	if (a->a_action) {
		error = _Xebec_action(a->a_action, e, p);
	}
	if (error == 0) {
		p->tpp_state = a->a_newstate;
	}
	return (error);
}
